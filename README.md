# Эталонный проект архитектуры фронтенд-приложения

## Описание

Данный проект представляет собой эталонную архитектуру для построения современных фронтенд-приложений на React с TypeScript. Проект демонстрирует чёткое разделение слоёв, продуманную структуру папок и эффективное взаимодействие между компонентами системы.

## Структура проекта

### Слои приложения

Проект разделен на следующие слои:

1. **Представление (UI)** - `components`, `pages`
2. **Бизнес-логика** - `stores`
3. **Сетевое взаимодействие** - `network`
4. **Инфраструктура** - `router`, `i18n`, `config`

### Описание директорий

#### `/src/components`

Переиспользуемые UI-компоненты, не содержащие бизнес-логики. Среди них:

- Базовые элементы управления
- Составные компоненты
- Компонент Layout для общей структуры страниц

#### `/src/pages`

Страницы приложения, объединяющие компоненты для формирования законченных экранов. Страницы подключаются к маршрутизатору и получают данные из сторов.

#### `/src/stores`

Слой бизнес-логики на базе MobX. Сторы отвечают за:

- Хранение состояния приложения
- Обработку бизнес-правил
- Взаимодействие с сетевым слоем
- Управление аутентификацией и авторизацией

#### `/src/network`

Сетевой слой для взаимодействия с API:

- `/auth` - аутентификация и авторизация
- `/users` - работа с пользователями
- `/role` - управление ролями
- Общие утилиты для обработки ответов и ошибок

#### `/src/router`

Настройка маршрутизации приложения с использованием библиотеки wouter:

- Определение маршрутов
- Защита маршрутов
- Перенаправления

#### `/src/i18n`

Интернационализация с использованием i18next:

- Переводы на разные языки
- Конфигурация i18n
- Утилиты для работы с переводами

#### `/src/config`

Конфигурация приложения:

- Константы
- Настройки окружения
- Глобальные параметры

## Взаимодействие между слоями

1. **UI → Бизнес-логика**: Компоненты и страницы подписываются на изменения в сторах через observer и вызывают действия (actions).

2. **Бизнес-логика → Сеть**: Сторы вызывают методы сетевого слоя для получения или изменения данных.

3. **Сеть → Бизнес-логика**: Сетевой слой возвращает данные или ошибки, которые обрабатываются в сторах.

4. **Инфраструктура**: Обеспечивает работу всех слоёв (маршрутизация, локализация, конфигурация).

## Технологии

- **React** - библиотека для построения интерфейсов
- **TypeScript** - строгая типизация для безопасной разработки
- **MobX** - управление состоянием приложения
- **React Query** - кеширование и синхронизация данных с сервером
- **i18next** - интернационализация
- **wouter** - легковесная маршрутизация
- **Vite** - быстрая сборка и разработка

## Особенности архитектуры

- **Чистое разделение ответственности** между слоями
- **Централизованное управление состоянием** через MobX сторы
- **Типобезопасность** на всех уровнях благодаря TypeScript
- **Масштабируемость** - легкое добавление новых функций без изменения существующего кода
- **Тестируемость** - изолированные компоненты и бизнес-логика

## Глобальная конфигурация и окружение

### AppConfig

Проект использует центральную конфигурацию `appConfig` в файле `/src/config/appConfig.ts`:

- **apiBaseUrl** - базовый URL для API-запросов
- **IS_MOCK_MODE** - флаг включения режима моков. В этом режиме все приложение работает на моках
- **IS_STORYBOOK** - флаг для определения контекста Storybook

Конфигурация может быть расширена дополнительными параметрами в зависимости от потребностей проекта.

### Переменные окружения

Проект поддерживает различные переменные окружения для разных сред разработки:

- **IS_MOCK_MODE** - включение/выключение режима моков
- **NODE_ENV** - окружение приложения (development, production, test)

Для локальной разработки можно использовать файл `.env.local`, который не включается в систему контроля версий.

## Моки данных и валидация

### Структура моков

Моки данных размещаются в директориях `mocks` внутри соответствующих модулей сетевого слоя:

```
src/network/auth/mocks/auth.mock.json
src/network/users/mocks/users.mock.json
src/network/role/mocks/roles.mock.json
```

### Автоматическая генерация схем

Для обеспечения типобезопасности и валидации моков используется Zod. Схемы генерируются автоматически на основе файлов `.mock.json` с помощью скрипта:

```bash
npm run generate-schemas
```

Скрипт анализирует структуру JSON-файлов и создает соответствующие Zod-схемы в файлах `.mock.schema.ts`.

### Пример сгенерированной схемы

```typescript
import { z } from "zod";

export const AuthSchema = z.object({
  token: z.string(),
  user: z.object({
    id: z.number().int(),
    name: z.string(),
    email: z.string().email(),
    roleIds: z.array(z.number().int()),
  }),
});

export type AuthSchemaType = z.infer<typeof AuthSchema>;
```

### Валидация в рантайме

Сгенерированные схемы используются для валидации данных во время выполнения приложения:

1. Валидация моков при загрузке
2. Валидация ответов от API
3. Типизация данных в компонентах и сторах

## Storybook и написание историй

### Структура историй

Истории размещаются рядом с компонентами или страницами с расширением `.stories.tsx`:

```
src/pages/LoginPage.stories.tsx
src/components/Button.stories.tsx
```

### Пример написания историй

На примере `LoginPage.stories.tsx` демонстрируется подход к написанию историй:

```typescript
import type { Meta, StoryObj } from "@storybook/react";
import { ComponentProps, FC } from "react";
import mockedUserData from "../network/auth/mocks/auth.mock.json";
import { $userStore } from "../stores/userStore";
import { LoginPage } from "./LoginPage";

type CombinedProps = Partial<typeof $userStore> &
  ComponentProps<typeof LoginPage> & { userName?: string };

const meta = {
  title: "Pages/LoginPage",
  component: LoginPage,
  parameters: {
    layout: "fullscreen",
  },
  decorators: [
    (Story) => {
      $userStore.isLoading = false;
      $userStore.error = null;
      $userStore.isAuthenticated = false;
      $userStore.user = null;

      return <Story />;
    },
  ],
} satisfies Meta<FC<CombinedProps>>;

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {};

export const WithError: Story = {
  decorators: [
    (Story) => {
      $userStore.error = new Error("Неверные учетные данные");
      return <Story />;
    },
  ],
};

export const Loading: Story = {
  decorators: [
    (Story) => {
      $userStore.isLoading = true;
      return <Story />;
    },
  ],
};

export const LoggedIn: Story = {
  args: {
    userName: "David",
  },
  render: (args) => {
    $userStore.isAuthenticated = true;
    $userStore.user = {
      ...mockedUserData.user,
      name: args.userName || mockedUserData.user.name,
    };

    return <LoginPage />;
  },
};
```

### Особенности написания историй

1. **Комбинированные типы** (`CombinedProps`) для объединения свойств компонента и состояний стора
2. **Декораторы** для настройки начального состояния сторов
3. **Варианты состояний** (Default, WithError, Loading) для визуализации разных состояний UI
4. **Кастомные аргументы** для управления данными через Storybook Controls
5. **Моки данных** используются непосредственно из файлов `.mock.json`

## Запуск проекта

```bash
# Установка зависимостей
npm install

# Запуск в режиме разработки
npm run dev

# Сборка проекта
npm run build

# Запуск Storybook
npm run storybook

# Генерация схем для моков
npm run generate-schemas
```
